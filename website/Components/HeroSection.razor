<section class="relative bg-black min-h-screen flex items-center justify-center overflow-hidden" id="hero-section">
    <!-- Background Pattern -->
    <div class="absolute inset-0 opacity-10 bg-gradient-to-r from-gray-900 to-gray-800">
        <div class="absolute inset-0" style="background-image: radial-gradient(circle at 2px 2px, white 1px, transparent 0); background-size: 80px 80px;"></div>
    </div>

    <!-- Floating Elements Container -->
    <div id="floating-elements" class="absolute inset-0 pointer-events-none">
        @foreach (var element in FloatingElements)
        {
            <div class="floating-element absolute @element.OpacityClass @element.ColorClass"
                 style="top: @(element.Top)%; left: @(element.Left)%; animation: @element.AnimationString;">
                <svg class="@element.SizeClass" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    @((MarkupString)element.SvgPath)
                </svg>
            </div>
        }
    </div>

    <div class="relative z-10 text-center px-4 sm:px-6 lg:px-8 max-w-6xl mx-auto">
        <!-- Main Title -->
        <div class="mb-16 text-center">
            <h1 class="text-6xl sm:text-7xl lg:text-8xl font-black text-white mb-8 tracking-tight">
                <span class="block font-extralight text-gray-300">ANDRES</span>
                <span class="block bg-gradient-to-r from-white to-gray-300 bg-clip-text text-transparent">
                    RAVELO
                </span>
            </h1>

            <!-- Interactive Role Buttons -->
            <div class="flex flex-wrap justify-center gap-6 text-lg sm:text-xl font-medium mb-12">
                <a href="/music" class="group flex items-center px-6 py-3 rounded-full border-2 border-gray-600 hover:border-white transition-all duration-300 hover:bg-white/5">
                    <div class="w-10 h-10 mr-4 rounded-full border border-gray-500 group-hover:border-white flex items-center justify-center transition-all duration-300">
                        <svg class="w-5 h-5 text-gray-400 group-hover:text-white transition-colors duration-300" fill="currentColor" viewBox="0 0 20 20">
                            <path d="M18 3a1 1 0 00-1.196-.98l-10 2A1 1 0 006 5v9.114A4.369 4.369 0 005 14c-1.657 0-3 .895-3 2s1.343 2 3 2 3-.895 3-2V7.82l8-1.6v5.894A4.369 4.369 0 0015 12c-1.657 0-3 .895-3 2s1.343 2 3 2 3-.895 3-2V3z"/>
                        </svg>
                    </div>
                    <span class="text-gray-300 group-hover:text-white transition-colors duration-300">Musician</span>
                </a>

                <a href="/developer" class="group flex items-center px-6 py-3 rounded-full border-2 border-gray-600 hover:border-white transition-all duration-300 hover:bg-white/5">
                    <div class="w-10 h-10 mr-4 rounded-full border border-gray-500 group-hover:border-white flex items-center justify-center transition-all duration-300">
                        <svg class="w-5 h-5 text-gray-400 group-hover:text-white transition-colors duration-300" fill="currentColor" viewBox="0 0 20 20">
                            <path fill-rule="evenodd" d="M12.316 3.051a1 1 0 01.633 1.265l-4 12a1 1 0 11-1.898-.632l4-12a1 1 0 011.265-.633zM5.707 6.293a1 1 0 010 1.414L3.414 10l2.293 2.293a1 1 0 11-1.414 1.414l-3-3a1 1 0 010-1.414l3-3a1 1 0 011.414 0zm8.586 0a1 1 0 011.414 0l3 3a1 1 0 010 1.414l-3 3a1 1 0 11-1.414-1.414L16.586 10l-2.293-2.293a1 1 0 010-1.414z" clip-rule="evenodd"/>
                        </svg>
                    </div>
                    <span class="text-gray-300 group-hover:text-white transition-colors duration-300">Developer</span>
                </a>

                <a href="/photography" class="group flex items-center px-6 py-3 rounded-full border-2 border-gray-600 hover:border-white transition-all duration-300 hover:bg-white/5">
                    <div class="w-10 h-10 mr-4 rounded-full border border-gray-500 group-hover:border-white flex items-center justify-center transition-all duration-300">
                        <svg class="w-5 h-5 text-gray-400 group-hover:text-white transition-colors duration-300" fill="currentColor" viewBox="0 0 20 20">
                            <path fill-rule="evenodd" d="M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z" clip-rule="evenodd"/>
                        </svg>
                    </div>
                    <span class="text-gray-300 group-hover:text-white transition-colors duration-300">Photographer</span>
                </a>
            </div>
        </div>
    </div>

</section>


<script>
document.addEventListener('DOMContentLoaded', function() {
    // üéõÔ∏è PHYSICS CONFIGURATION - Tweak these values!
    const CONFIG = {
        // Movement Physics
        INITIAL_VELOCITY: 0.03,        // How fast they start moving (0.1 = faster, 0.01 = slower)
        MAX_SPEED: 0.08,               // Maximum speed limit (0.15 = faster, 0.05 = slower)
        FRICTION: 0.895,               // How much they slow down (0.98 = more friction, 0.999 = less friction)

        // Gravity & Positioning
        RETURN_FORCE: 0.003,           // How strong the pull back to original position (0.002 = stronger, 0.0005 = weaker)
        BOUNDARY_PUSH: 0.005,          // How hard they bounce off edges (0.01 = harder, 0.001 = softer)

        // Collision Detection
        COLLISION_RADIUS: 3,           // How close before they push apart (8 = more spacing, 4 = less spacing)
        COLLISION_FORCE: 0.02,         // How hard they push each other (0.02 = harder, 0.005 = softer)

        // Mouse Interaction
        MOUSE_DISTANCE: 10,            // How close mouse needs to be for effects (12 = further, 6 = closer)
        MOUSE_REPEL_FORCE: 0.05,       // How hard mouse pushes them away (0.1 = stronger, 0.02 = weaker)

        // Visual Effects
        GLOW_MAX_SIZE: 40,             // Maximum glow size (60 = bigger, 20 = smaller)
        SCALE_MAX: 0.2,                // Maximum scale increase (0.3 = bigger, 0.1 = smaller)

        // Performance
        TARGET_FPS: 60,                // Animation frame rate
        BOUNDARY_MARGIN: 5,             // Distance from edges before boundary push

        // üì± RESPONSIVE ICON COUNTS
        ICON_COUNT: {
            mobile: 8,      // üì± Phone: Just a few for performance
            tablet: 15,     // üì± Tablet: Medium amount
            desktop: 35,    // üíª Desktop: Full experience
            large: 50       // üñ•Ô∏è Large screens: Maximum beauty
        }
    };

    // üìè Detect device type based on screen size
    function getDeviceType() {
        const width = window.innerWidth;
        if (width < 640) return 'mobile';        // sm breakpoint
        if (width < 1024) return 'tablet';       // lg breakpoint
        if (width < 1440) return 'desktop';      // xl breakpoint
        return 'large';                          // 2xl+
    }

    // üéØ Get icon count for current device
    function getIconCount() {
        const deviceType = getDeviceType();
        return CONFIG.ICON_COUNT[deviceType];
    }

    const heroSection = document.getElementById('hero-section');
    let floatingElements = document.querySelectorAll('.floating-element');

    // üì± Adjust icon count based on screen size
    const targetIconCount = getIconCount();
    const currentIconCount = floatingElements.length;

    console.log(`üéØ Device: ${getDeviceType()}, Target icons: ${targetIconCount}, Current: ${currentIconCount}`);

    // Hide excess icons if we have too many for this device
    if (currentIconCount > targetIconCount) {
        Array.from(floatingElements).forEach((element, index) => {
            if (index >= targetIconCount) {
                element.style.display = 'none';
            }
        });
        // Update the NodeList to only include visible elements
        floatingElements = Array.from(document.querySelectorAll('.floating-element')).filter(el => el.style.display !== 'none');
    }

    // Performance optimization: cache elements data
    const elementsData = Array.from(floatingElements).map((element, index) => ({
        element,
        id: index,
        x: parseFloat(element.style.left),
        y: parseFloat(element.style.top),
        vx: (Math.random() - 0.5) * CONFIG.INITIAL_VELOCITY,
        vy: (Math.random() - 0.5) * CONFIG.INITIAL_VELOCITY,
        radius: CONFIG.COLLISION_RADIUS,
        originalX: parseFloat(element.style.left),
        originalY: parseFloat(element.style.top)
    }));

    let animationId;
    let lastTime = 0;
    const frameTime = 1000 / CONFIG.TARGET_FPS;

    // üì± Adjust physics based on device (lighter physics for mobile)
    const deviceType = getDeviceType();
    if (deviceType === 'mobile') {
        CONFIG.INITIAL_VELOCITY *= 0.5;  // Slower on mobile
        CONFIG.MAX_SPEED *= 0.5;         // Less chaos
        CONFIG.MOUSE_REPEL_FORCE *= 0.5; // Gentler interactions
        CONFIG.TARGET_FPS = 30;          // Better performance
    }

    // High-performance animation loop
    function animate(currentTime) {
        if (currentTime - lastTime >= frameTime) {
            updatePositions();
            checkCollisions();
            lastTime = currentTime;
        }
        animationId = requestAnimationFrame(animate);
    }

    function updatePositions() {
        elementsData.forEach(data => {
            // Gentle gravity towards original position
            const dx = data.originalX - data.x;
            const dy = data.originalY - data.y;

            data.vx += dx * CONFIG.RETURN_FORCE;
            data.vy += dy * CONFIG.RETURN_FORCE;

            // Apply friction
            data.vx *= CONFIG.FRICTION;
            data.vy *= CONFIG.FRICTION;

            // Update positions
            data.x += data.vx;
            data.y += data.vy;

            // Soft boundary constraints
            if (data.x < CONFIG.BOUNDARY_MARGIN) {
                data.vx += (CONFIG.BOUNDARY_MARGIN - data.x) * CONFIG.BOUNDARY_PUSH;
            }
            if (data.x > 95 - CONFIG.BOUNDARY_MARGIN) {
                data.vx -= (data.x - (95 - CONFIG.BOUNDARY_MARGIN)) * CONFIG.BOUNDARY_PUSH;
            }
            if (data.y < CONFIG.BOUNDARY_MARGIN) {
                data.vy += (CONFIG.BOUNDARY_MARGIN - data.y) * CONFIG.BOUNDARY_PUSH;
            }
            if (data.y > 95 - CONFIG.BOUNDARY_MARGIN) {
                data.vy -= (data.y - (95 - CONFIG.BOUNDARY_MARGIN)) * CONFIG.BOUNDARY_PUSH;
            }

            // Apply position
            data.element.style.left = `${data.x}%`;
            data.element.style.top = `${data.y}%`;
        });
    }

    function checkCollisions() {
        for (let i = 0; i < elementsData.length; i++) {
            for (let j = i + 1; j < elementsData.length; j++) {
                const a = elementsData[i];
                const b = elementsData[j];

                const dx = a.x - b.x;
                const dy = a.y - b.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Collision detected
                if (distance < a.radius) {
                    const angle = Math.atan2(dy, dx);

                    // Push elements apart
                    a.vx += Math.cos(angle) * CONFIG.COLLISION_FORCE;
                    a.vy += Math.sin(angle) * CONFIG.COLLISION_FORCE;
                    b.vx -= Math.cos(angle) * CONFIG.COLLISION_FORCE;
                    b.vy -= Math.sin(angle) * CONFIG.COLLISION_FORCE;

                    // Limit velocity
                    a.vx = Math.max(-CONFIG.MAX_SPEED, Math.min(CONFIG.MAX_SPEED, a.vx));
                    a.vy = Math.max(-CONFIG.MAX_SPEED, Math.min(CONFIG.MAX_SPEED, a.vy));
                    b.vx = Math.max(-CONFIG.MAX_SPEED, Math.min(CONFIG.MAX_SPEED, b.vx));
                    b.vy = Math.max(-CONFIG.MAX_SPEED, Math.min(CONFIG.MAX_SPEED, b.vy));
                }
            }
        }
    }

    // Mouse interaction
    let mouseX = 0, mouseY = 0;
    let isMouseMoving = false;

    heroSection.addEventListener('mousemove', function(e) {
        const rect = heroSection.getBoundingClientRect();
        mouseX = ((e.clientX - rect.left) / rect.width) * 100;
        mouseY = ((e.clientY - rect.top) / rect.height) * 100;
        isMouseMoving = true;

        requestAnimationFrame(updateMouseEffects);
    });

    function updateMouseEffects() {
        if (!isMouseMoving) return;

        elementsData.forEach(data => {
            const dx = mouseX - data.x;
            const dy = mouseY - data.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < CONFIG.MOUSE_DISTANCE) {
                const intensity = Math.max(0, (CONFIG.MOUSE_DISTANCE - distance) / CONFIG.MOUSE_DISTANCE);
                const glowSize = Math.round(intensity * CONFIG.GLOW_MAX_SIZE);
                const opacity = intensity * 2;
                const brightness = 1 + intensity * 2;
                const scale = 1 + intensity * CONFIG.SCALE_MAX;

                // Glow effect
                data.element.style.filter = `
                    drop-shadow(0 0 ${glowSize}px rgba(0, 150, 255, ${opacity}))
                    drop-shadow(0 0 ${glowSize * 1.5}px rgba(100, 200, 255, ${opacity * 0.8}))
                    brightness(${brightness})
                `;
                data.element.style.transform = `scale(${scale})`;
                data.element.style.transition = 'none';

                // Mouse repulsion
                const angle = Math.atan2(data.y - mouseY, data.x - mouseX);
                data.vx += Math.cos(angle) * CONFIG.MOUSE_REPEL_FORCE * intensity;
                data.vy += Math.sin(angle) * CONFIG.MOUSE_REPEL_FORCE * intensity;
            } else {
                // Reset effects
                data.element.style.filter = '';
                data.element.style.transform = '';
                data.element.style.transition = 'filter 0.15s ease-out, transform 0.15s ease-out';
            }
        });

        isMouseMoving = false;
    }

    heroSection.addEventListener('mouseleave', function() {
        elementsData.forEach(data => {
            data.element.style.filter = '';
            data.element.style.transform = '';
            data.element.style.transition = 'filter 0.2s ease-out, transform 0.2s ease-out';
        });
    });

    // üì± Handle screen resize - adjust icon count if needed
    let resizeTimeout;
    window.addEventListener('resize', function() {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            const newIconCount = getIconCount();
            const currentVisible = elementsData.length;

            if (newIconCount !== currentVisible) {
                console.log(`üîÑ Screen resized: adjusting icons from ${currentVisible} to ${newIconCount}`);
                // Reload page for simplicity (or implement dynamic show/hide)
                location.reload();
            }
        }, 250);
    });

    // Start the animation loop
    animate(0);

    // Cleanup on page unload
    window.addEventListener('beforeunload', function() {
        if (animationId) {
            cancelAnimationFrame(animationId);
        }
    });
});
</script>

<style>
    .floating-element {
        will-change: transform, left, top;
    }
</style>


@code {

    private List<FloatingElement> FloatingElements = new();

    protected override void OnInitialized()
    {
        GenerateFloatingElements();
    }

    private void GenerateFloatingElements()
    {
        var random = new Random();
        var svgIcons = GetSvgIcons();
        var sizes = new[] { "w-6 h-6", "w-7 h-7", "w-8 h-8", "w-10 h-10" };
        var opacities = new[] { "opacity-20" };
        var colors = new[] { "text-gray-300" };

        for (int i = 0; i < 50; i++) // Keep this at 50 (max for large screens)
        {
            FloatingElements.Add(new FloatingElement
            {
                Top = random.Next(5, 95),
                Left = random.Next(5, 95),
                SvgPath = svgIcons[random.Next(svgIcons.Count)],
                SizeClass = sizes[random.Next(sizes.Length)],
                OpacityClass = opacities[random.Next(opacities.Length)],
                ColorClass = colors[random.Next(colors.Length)],
                AnimationIndex = 0,
                Duration = 0,
                DurationUnit = "s"
            });
        }
    }



    private List<string> GetSvgIcons()
    {
        return new List<string>
        {
            // üéµ Music Icons

            """<ellipse cx="7" cy="17" rx="2" ry="1.5" stroke="currentColor" stroke-width="1.5" fill="currentColor"/><path stroke="currentColor" stroke-width="1.5" stroke-linecap="round" d="M9 17V6l7-2v11"/><ellipse cx="14" cy="15" rx="2" ry="1.5" stroke="currentColor" stroke-width="1.5" fill="currentColor"/>""", // Double notes with stems

            // üì∑ Camera Icons
            """<path stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" fill="none" d="M14.5 4h-5L7 6H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-3l-2.5-2z"/><circle cx="12" cy="13" r="3" stroke="currentColor" stroke-width="1.5" fill="none"/>""", // Perfect camera

            """<circle cx="12" cy="12" r="9" stroke="currentColor" stroke-width="1.5" fill="none"/><circle cx="12" cy="12" r="3" stroke="currentColor" stroke-width="1.5" fill="none"/><circle cx="16" cy="8" r="1" fill="currentColor"/>""", // Camera lens

        };
    }


    public class FloatingElement
    {
        public int Top { get; set; }
        public int Left { get; set; }
        public string SvgPath { get; set; } = "";
        public string SizeClass { get; set; } = "";
        public string OpacityClass { get; set; } = "";
        public string ColorClass { get; set; } = "";
        public int AnimationIndex { get; set; }
        public int Duration { get; set; }
        public string DurationUnit { get; set; } = "s";
        public string AnimationString => "";
    }


}